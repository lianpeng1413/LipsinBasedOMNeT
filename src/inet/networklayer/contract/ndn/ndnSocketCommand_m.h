//
// Generated file, do not edit! Created by nedtool 5.6 from inet/networklayer/contract/ndn/ndnSocketCommand.msg.
//

#ifndef __INET_NDNSOCKETCOMMAND_M_H
#define __INET_NDNSOCKETCOMMAND_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0506
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// dll export symbol
#ifndef INET_API
#  if defined(INET_EXPORT)
#    define INET_API  OPP_DLLEXPORT
#  elif defined(INET_IMPORT)
#    define INET_API  OPP_DLLIMPORT
#  else
#    define INET_API
#  endif
#endif


namespace inet {

class ndnSocketCommandBase;
class ndnSocketBindCommand;
class ndnSocketSendInterestCommand;
class ndnSocketCacheDataCommand;
class ndnSocketCloseCommand;
class ndnSocketDestroyCommand;
} // namespace inet

#include "inet/common/INETDefs_m.h" // import inet.common.INETDefs

#include "inet/common/Protocol_m.h" // import inet.common.Protocol

#include "inet/networklayer/contract/ndn/ndnFields_m.h" // import inet.networklayer.contract.ndn.ndnFields


namespace inet {

/**
 * Enum generated from <tt>inet/networklayer/contract/ndn/ndnSocketCommand.msg:23</tt> by nedtool.
 * <pre>
 * enum ndnCommandCode
 * {
 *     NDN_C_BIND = 1;
 *     NDN_C_SEND_INTEREST = 2;
 *     NDN_C_CLOSE = 3;
 *     NDN_C_DESTROY = 4;
 *     NDN_C_CACHE_DATA = 5;
 * }
 * </pre>
 */
enum ndnCommandCode {
    NDN_C_BIND = 1,
    NDN_C_SEND_INTEREST = 2,
    NDN_C_CLOSE = 3,
    NDN_C_DESTROY = 4,
    NDN_C_CACHE_DATA = 5
};

/**
 * Enum generated from <tt>inet/networklayer/contract/ndn/ndnSocketCommand.msg:31</tt> by nedtool.
 * <pre>
 * enum ndnStatusInd
 * {
 *     NDN_I_DATA = 0;
 *     NDN_I_SOCKET_CLOSED = 1;
 * }
 * </pre>
 */
enum ndnStatusInd {
    NDN_I_DATA = 0,
    NDN_I_SOCKET_CLOSED = 1
};

/**
 * Class generated from <tt>inet/networklayer/contract/ndn/ndnSocketCommand.msg:37</tt> by nedtool.
 * <pre>
 * class ndnSocketCommandBase extends cObject
 * {
 * }
 * </pre>
 */
class INET_API ndnSocketCommandBase : public ::omnetpp::cObject
{
  protected:

  private:
    void copy(const ndnSocketCommandBase& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ndnSocketCommandBase&);

  public:
    ndnSocketCommandBase();
    ndnSocketCommandBase(const ndnSocketCommandBase& other);
    virtual ~ndnSocketCommandBase();
    ndnSocketCommandBase& operator=(const ndnSocketCommandBase& other);
    virtual ndnSocketCommandBase *dup() const override {return new ndnSocketCommandBase(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const ndnSocketCommandBase& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, ndnSocketCommandBase& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/contract/ndn/ndnSocketCommand.msg:42</tt> by nedtool.
 * <pre>
 * class ndnSocketBindCommand extends ndnSocketCommandBase
 * {
 *     const Protocol *protocol;
 *     int localPort;
 *     iName nid;
 * }
 * </pre>
 */
class INET_API ndnSocketBindCommand : public ::inet::ndnSocketCommandBase
{
  protected:
    const Protocol * protocol = nullptr;
    int localPort = 0;
    iName nid;

  private:
    void copy(const ndnSocketBindCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ndnSocketBindCommand&);

  public:
    ndnSocketBindCommand();
    ndnSocketBindCommand(const ndnSocketBindCommand& other);
    virtual ~ndnSocketBindCommand();
    ndnSocketBindCommand& operator=(const ndnSocketBindCommand& other);
    virtual ndnSocketBindCommand *dup() const override {return new ndnSocketBindCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const Protocol * getProtocol() const;
    virtual void setProtocol(const Protocol * protocol);
    virtual int getLocalPort() const;
    virtual void setLocalPort(int localPort);
    virtual const iName& getNid() const;
    virtual iName& getNidForUpdate() { return const_cast<iName&>(const_cast<ndnSocketBindCommand*>(this)->getNid());}
    virtual void setNid(const iName& nid);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const ndnSocketBindCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, ndnSocketBindCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/contract/ndn/ndnSocketCommand.msg:49</tt> by nedtool.
 * <pre>
 * class ndnSocketSendInterestCommand extends ndnSocketCommandBase
 * {
 *     iName interest;
 *     int localPort;
 *     double Inter;
 * }
 * </pre>
 */
class INET_API ndnSocketSendInterestCommand : public ::inet::ndnSocketCommandBase
{
  protected:
    iName interest;
    int localPort = 0;
    double Inter = 0;

  private:
    void copy(const ndnSocketSendInterestCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ndnSocketSendInterestCommand&);

  public:
    ndnSocketSendInterestCommand();
    ndnSocketSendInterestCommand(const ndnSocketSendInterestCommand& other);
    virtual ~ndnSocketSendInterestCommand();
    ndnSocketSendInterestCommand& operator=(const ndnSocketSendInterestCommand& other);
    virtual ndnSocketSendInterestCommand *dup() const override {return new ndnSocketSendInterestCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const iName& getInterest() const;
    virtual iName& getInterestForUpdate() { return const_cast<iName&>(const_cast<ndnSocketSendInterestCommand*>(this)->getInterest());}
    virtual void setInterest(const iName& interest);
    virtual int getLocalPort() const;
    virtual void setLocalPort(int localPort);
    virtual double getInter() const;
    virtual void setInter(double Inter);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const ndnSocketSendInterestCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, ndnSocketSendInterestCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/contract/ndn/ndnSocketCommand.msg:56</tt> by nedtool.
 * <pre>
 * class ndnSocketCacheDataCommand extends ndnSocketCommandBase
 * {
 *     iName interest;
 *     cMessage *pkt;
 * }
 * </pre>
 */
class INET_API ndnSocketCacheDataCommand : public ::inet::ndnSocketCommandBase
{
  protected:
    iName interest;
    cMessage * pkt = nullptr;

  private:
    void copy(const ndnSocketCacheDataCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ndnSocketCacheDataCommand&);

  public:
    ndnSocketCacheDataCommand();
    ndnSocketCacheDataCommand(const ndnSocketCacheDataCommand& other);
    virtual ~ndnSocketCacheDataCommand();
    ndnSocketCacheDataCommand& operator=(const ndnSocketCacheDataCommand& other);
    virtual ndnSocketCacheDataCommand *dup() const override {return new ndnSocketCacheDataCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const iName& getInterest() const;
    virtual iName& getInterestForUpdate() { return const_cast<iName&>(const_cast<ndnSocketCacheDataCommand*>(this)->getInterest());}
    virtual void setInterest(const iName& interest);
    virtual const cMessage * getPkt() const;
    virtual cMessage * getPktForUpdate() { return const_cast<cMessage *>(const_cast<ndnSocketCacheDataCommand*>(this)->getPkt());}
    virtual void setPkt(cMessage * pkt);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const ndnSocketCacheDataCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, ndnSocketCacheDataCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/contract/ndn/ndnSocketCommand.msg:62</tt> by nedtool.
 * <pre>
 * class ndnSocketCloseCommand extends ndnSocketCommandBase
 * {
 * }
 * </pre>
 */
class INET_API ndnSocketCloseCommand : public ::inet::ndnSocketCommandBase
{
  protected:

  private:
    void copy(const ndnSocketCloseCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ndnSocketCloseCommand&);

  public:
    ndnSocketCloseCommand();
    ndnSocketCloseCommand(const ndnSocketCloseCommand& other);
    virtual ~ndnSocketCloseCommand();
    ndnSocketCloseCommand& operator=(const ndnSocketCloseCommand& other);
    virtual ndnSocketCloseCommand *dup() const override {return new ndnSocketCloseCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const ndnSocketCloseCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, ndnSocketCloseCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/contract/ndn/ndnSocketCommand.msg:66</tt> by nedtool.
 * <pre>
 * class ndnSocketDestroyCommand extends ndnSocketCommandBase
 * {
 * }
 * </pre>
 */
class INET_API ndnSocketDestroyCommand : public ::inet::ndnSocketCommandBase
{
  protected:

  private:
    void copy(const ndnSocketDestroyCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ndnSocketDestroyCommand&);

  public:
    ndnSocketDestroyCommand();
    ndnSocketDestroyCommand(const ndnSocketDestroyCommand& other);
    virtual ~ndnSocketDestroyCommand();
    ndnSocketDestroyCommand& operator=(const ndnSocketDestroyCommand& other);
    virtual ndnSocketDestroyCommand *dup() const override {return new ndnSocketDestroyCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const ndnSocketDestroyCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, ndnSocketDestroyCommand& obj) {obj.parsimUnpack(b);}

} // namespace inet

#endif // ifndef __INET_NDNSOCKETCOMMAND_M_H

